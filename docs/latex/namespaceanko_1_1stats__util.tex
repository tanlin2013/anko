\hypertarget{namespaceanko_1_1stats__util}{}\doxysection{anko.\+stats\+\_\+util Namespace Reference}
\label{namespaceanko_1_1stats__util}\index{anko.stats\_util@{anko.stats\_util}}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \mbox{\hyperlink{namespaceanko_1_1stats__util_ae5da820a4ff2ba172cc895f7aed1a7c6}{get\+\_\+histogram}} (np.\+ndarray x, bool sort\+\_\+histo=False)
\begin{DoxyCompactList}\small\item\em Return the corresponding histogram of the data x. \end{DoxyCompactList}\item 
np.\+ndarray \mbox{\hyperlink{namespaceanko_1_1stats__util_a043c3334f258dda9e528ab8a51ea053b}{normal\+\_\+distr}} (np.\+ndarray x, float a, float x0, float sigma)
\begin{DoxyCompactList}\small\item\em Calculate normal distribution of input array x. \end{DoxyCompactList}\item 
def \mbox{\hyperlink{namespaceanko_1_1stats__util_aa482297a54c4bcc67af00b259c3b03ce}{gaussian\+\_\+fit}} (np.\+ndarray x, bool sort\+\_\+histo=False, str half=None, int maxfev=2000, bounds=\mbox{[}0, 1e+6\mbox{]})
\begin{DoxyCompactList}\small\item\em Fitting the Gaussian (normal) distribution for input data x. \end{DoxyCompactList}\item 
np.\+ndarray \mbox{\hyperlink{namespaceanko_1_1stats__util_afe9294ceb5073c65f77b6c7894349ef7}{left\+\_\+half\+\_\+normal\+\_\+distr}} (np.\+ndarray x, float a, float x0, float sigma)
\begin{DoxyCompactList}\small\item\em Calculate left-\/side half normal distribution of input array x. \end{DoxyCompactList}\item 
np.\+ndarray \mbox{\hyperlink{namespaceanko_1_1stats__util_ad0683a7fc4d68fa7937dbe214d554997}{right\+\_\+half\+\_\+normal\+\_\+distr}} (np.\+ndarray x, float a, float x0, float sigma)
\begin{DoxyCompactList}\small\item\em Calculate right-\/side half normal distribution of input array x. \end{DoxyCompactList}\item 
def \mbox{\hyperlink{namespaceanko_1_1stats__util_a592ce686a07fad2982a1e051b8e751da}{flat\+\_\+histogram}} (np.\+ndarray x)
\begin{DoxyCompactList}\small\item\em Deprecating... \end{DoxyCompactList}\item 
def \mbox{\hyperlink{namespaceanko_1_1stats__util_a15eb3a4bb50aa7e2825e03c741684c0e}{linear\+\_\+regression}} (np.\+ndarray x, np.\+ndarray y)
\begin{DoxyCompactList}\small\item\em Fitting linear ansatz for input data (x, y). \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceanko_1_1stats__util_ad350eac604ebf2d6d3c42f4753d882de}{data\+\_\+is\+\_\+linear}} (np.\+ndarray x, np.\+ndarray y, float std\+\_\+err\+\_\+th=1e-\/2)
\begin{DoxyCompactList}\small\item\em Check whether the data (x, y) is linear under the given tolerance. \end{DoxyCompactList}\item 
np.\+ndarray \mbox{\hyperlink{namespaceanko_1_1stats__util_a9e0f971311c5d1013a90795d2427091c}{general\+\_\+erf}} (np.\+ndarray x, float a, float b, float x0)
\begin{DoxyCompactList}\small\item\em Calculate the generalize error function of input array x. \end{DoxyCompactList}\item 
np.\+ndarray \mbox{\hyperlink{namespaceanko_1_1stats__util_a2efdfc173ad6b38025bfd48da53f160a}{three\+\_\+stair\+\_\+erf}} (np.\+ndarray x, float c0, float c1, float c2, float x1, float x2)
\begin{DoxyCompactList}\small\item\em Calculate the generalize error function with three stairs for input array x. \end{DoxyCompactList}\item 
def \mbox{\hyperlink{namespaceanko_1_1stats__util_a4f434d24322b90d1d03cf689847ea76a}{general\+\_\+erf\+\_\+fit}} (np.\+ndarray x, np.\+ndarray y, bool three\+\_\+stair=False, int maxfev=2000, bounds=\mbox{[}0, 1e+6\mbox{]})
\begin{DoxyCompactList}\small\item\em Fitting generalize error function for input data (x, y). \end{DoxyCompactList}\item 
np.\+ndarray \mbox{\hyperlink{namespaceanko_1_1stats__util_aa196811391f6401b6fec78c1fd7054ed}{exp\+\_\+decay}} (np.\+ndarray x, float a, float alpha)
\begin{DoxyCompactList}\small\item\em Calculate the exponential function of input array x. \end{DoxyCompactList}\item 
def \mbox{\hyperlink{namespaceanko_1_1stats__util_a4ae884cfdb74b45070f1c07b2f9527b1}{exp\+\_\+decay\+\_\+fit}} (np.\+ndarray x, np.\+ndarray y, str mode=\textquotesingle{}log-\/linregress\textquotesingle{}, int maxfev=2000, bounds=\mbox{[}-\/1e-\/6, 1e+6\mbox{]})
\item 
def \mbox{\hyperlink{namespaceanko_1_1stats__util_a1467292292fb037a7b879c3a66700499}{smoothness}} (np.\+ndarray x, bool normalize=False)
\item 
def \mbox{\hyperlink{namespaceanko_1_1stats__util_aebff1af496b1545f67e9b7a9253f2226}{discontinuous\+\_\+idx}} (np.\+ndarray x, int std\+\_\+width=1)
\begin{DoxyCompactList}\small\item\em Compute derivative of input array x, and organize the result into z-\/score standardized formulation. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceanko_1_1stats__util_a0f75e0a66974df60bf657d244f516619}{is\+\_\+oscillating}} (np.\+ndarray x, float osci\+\_\+freq\+\_\+th=0.\+3)
\begin{DoxyCompactList}\small\item\em Determine whether the input array x is oscillating over its mean with frequency larger than osci\+\_\+freq\+\_\+th. \end{DoxyCompactList}\item 
np.\+ndarray \mbox{\hyperlink{namespaceanko_1_1stats__util_a6f905598561c0f8c6e31dfb0b0e2d5e5}{fitting\+\_\+residual}} (np.\+ndarray x, np.\+ndarray y, func, args, float mask\+\_\+min=None, bool absolute\+\_\+value=True, bool standardized=False)
\begin{DoxyCompactList}\small\item\em Compute the fitting residual. \end{DoxyCompactList}\item 
float \mbox{\hyperlink{namespaceanko_1_1stats__util_a722a7df4e57d07d0db0536c8d77492e5}{A\+I\+C\+\_\+score}} (np.\+ndarray y, np.\+ndarray y\+\_\+predict, int p)
\begin{DoxyCompactList}\small\item\em Compute Akaike information criterion for model selection. \end{DoxyCompactList}\item 
float \mbox{\hyperlink{namespaceanko_1_1stats__util_a8c9c7a4adfcf1719ffa5a445cac7c7c7}{B\+I\+C\+\_\+score}} (np.\+ndarray y, np.\+ndarray y\+\_\+predict, int p)
\begin{DoxyCompactList}\small\item\em Compute Bayesian information criterion for model selection. \end{DoxyCompactList}\item 
np.\+ndarray \mbox{\hyperlink{namespaceanko_1_1stats__util_a9b2e2041bcd620bb46b85e933fe45697}{z\+\_\+normalization}} (np.\+ndarray x)
\begin{DoxyCompactList}\small\item\em Perform z-\/score normalizaion on input array x. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespaceanko_1_1stats__util_a722a7df4e57d07d0db0536c8d77492e5}\label{namespaceanko_1_1stats__util_a722a7df4e57d07d0db0536c8d77492e5}} 
\index{anko.stats\_util@{anko.stats\_util}!AIC\_score@{AIC\_score}}
\index{AIC\_score@{AIC\_score}!anko.stats\_util@{anko.stats\_util}}
\doxysubsubsection{\texorpdfstring{AIC\_score()}{AIC\_score()}}
{\footnotesize\ttfamily  float anko.\+stats\+\_\+util.\+A\+I\+C\+\_\+score (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{y,  }\item[{np.\+ndarray}]{y\+\_\+predict,  }\item[{int}]{p }\end{DoxyParamCaption})}



Compute Akaike information criterion for model selection. 

\begin{equation*} \mathcal{AIC} = n \log(\mathcal{RSS}/n) + 2p, \end{equation*} where $ \mathcal{RSS} $ is the residual sum of squares, and $ n $ is the number of data samples.


\begin{DoxyParams}{Parameters}
{\em y} & (numpy.\+ndarray)\+: Data samples. \\
\hline
{\em y\+\_\+predict} & (numpy.\+ndarray)\+: Prediction by fitting. \\
\hline
{\em p} & (int)\+: Fitting degrees of freedom, i.\+e. the number of parameters to fit with.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
aic\+\_\+score (float)\+: 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceanko_1_1stats__util_a8c9c7a4adfcf1719ffa5a445cac7c7c7}\label{namespaceanko_1_1stats__util_a8c9c7a4adfcf1719ffa5a445cac7c7c7}} 
\index{anko.stats\_util@{anko.stats\_util}!BIC\_score@{BIC\_score}}
\index{BIC\_score@{BIC\_score}!anko.stats\_util@{anko.stats\_util}}
\doxysubsubsection{\texorpdfstring{BIC\_score()}{BIC\_score()}}
{\footnotesize\ttfamily  float anko.\+stats\+\_\+util.\+B\+I\+C\+\_\+score (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{y,  }\item[{np.\+ndarray}]{y\+\_\+predict,  }\item[{int}]{p }\end{DoxyParamCaption})}



Compute Bayesian information criterion for model selection. 

\begin{equation*} \mathcal{BIC} = n \log(\mathcal{RSS}/n) + p \log(n), \end{equation*} where $ \mathcal{RSS} $ is the residual sum of squares, and $ n $ is the number of data samples.


\begin{DoxyParams}{Parameters}
{\em y} & (numpy.\+ndarray)\+: Data samples. \\
\hline
{\em y\+\_\+predict} & (numpy.\+ndarray)\+: Prediction by fitting. \\
\hline
{\em p} & (int)\+: Fitting degrees of freedom, i.\+e. the number of parameters to fit with.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bic\+\_\+score (float)\+: 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceanko_1_1stats__util_ad350eac604ebf2d6d3c42f4753d882de}\label{namespaceanko_1_1stats__util_ad350eac604ebf2d6d3c42f4753d882de}} 
\index{anko.stats\_util@{anko.stats\_util}!data\_is\_linear@{data\_is\_linear}}
\index{data\_is\_linear@{data\_is\_linear}!anko.stats\_util@{anko.stats\_util}}
\doxysubsubsection{\texorpdfstring{data\_is\_linear()}{data\_is\_linear()}}
{\footnotesize\ttfamily  bool anko.\+stats\+\_\+util.\+data\+\_\+is\+\_\+linear (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{x,  }\item[{np.\+ndarray}]{y,  }\item[{float}]{std\+\_\+err\+\_\+th = {\ttfamily 1e-\/2} }\end{DoxyParamCaption})}



Check whether the data (x, y) is linear under the given tolerance. 

~\newline
This will perform a linear regression fitting.


\begin{DoxyParams}{Parameters}
{\em x} & (numpy.\+ndarray)\+: x coordinate of input data points. \\
\hline
{\em y} & (numpy.\+ndarray)\+: y coordinate of input data points. \\
\hline
{\em std\+\_\+err\+\_\+th} & (float, optional)\+: Threshold value of std\+\_\+err.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
out (bool)\+: Return Ture if data is flat, else return False. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceanko_1_1stats__util_aebff1af496b1545f67e9b7a9253f2226}\label{namespaceanko_1_1stats__util_aebff1af496b1545f67e9b7a9253f2226}} 
\index{anko.stats\_util@{anko.stats\_util}!discontinuous\_idx@{discontinuous\_idx}}
\index{discontinuous\_idx@{discontinuous\_idx}!anko.stats\_util@{anko.stats\_util}}
\doxysubsubsection{\texorpdfstring{discontinuous\_idx()}{discontinuous\_idx()}}
{\footnotesize\ttfamily def anko.\+stats\+\_\+util.\+discontinuous\+\_\+idx (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{x,  }\item[{int}]{std\+\_\+width = {\ttfamily 1} }\end{DoxyParamCaption})}



Compute derivative of input array x, and organize the result into z-\/score standardized formulation. 

Once this analysis is done, normalized results are masked for those magnitudes that are smaller than std\+\_\+width, in order to ignore noises.


\begin{DoxyParams}{Parameters}
{\em x} & (numpy.\+ndarray)\+: Input Values. \\
\hline
{\em std\+\_\+width} & (int)\+: Threshold values for masking noises.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
idx (numpy.\+ndarray)\+: Indices of discontinuous points in input array x. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceanko_1_1stats__util_aa196811391f6401b6fec78c1fd7054ed}\label{namespaceanko_1_1stats__util_aa196811391f6401b6fec78c1fd7054ed}} 
\index{anko.stats\_util@{anko.stats\_util}!exp\_decay@{exp\_decay}}
\index{exp\_decay@{exp\_decay}!anko.stats\_util@{anko.stats\_util}}
\doxysubsubsection{\texorpdfstring{exp\_decay()}{exp\_decay()}}
{\footnotesize\ttfamily  np.\+ndarray anko.\+stats\+\_\+util.\+exp\+\_\+decay (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{x,  }\item[{float}]{a,  }\item[{float}]{alpha }\end{DoxyParamCaption})}



Calculate the exponential function of input array x. 

Note that domain of x $>$= 0.

\begin{equation*} f(x) = a\exp\left(-\alpha x\right). \end{equation*}


\begin{DoxyParams}{Parameters}
{\em x} & (numpy.\+ndarray)\+: Input values. \\
\hline
{\em a} & (float)\+: Overall normalized constant. \\
\hline
{\em alpha} & (float)\+: Decay rate of exponential function. Please note that $ \alpha $ can be negative, and should be carefully utilized.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
out\+: Output array. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceanko_1_1stats__util_a4ae884cfdb74b45070f1c07b2f9527b1}\label{namespaceanko_1_1stats__util_a4ae884cfdb74b45070f1c07b2f9527b1}} 
\index{anko.stats\_util@{anko.stats\_util}!exp\_decay\_fit@{exp\_decay\_fit}}
\index{exp\_decay\_fit@{exp\_decay\_fit}!anko.stats\_util@{anko.stats\_util}}
\doxysubsubsection{\texorpdfstring{exp\_decay\_fit()}{exp\_decay\_fit()}}
{\footnotesize\ttfamily def anko.\+stats\+\_\+util.\+exp\+\_\+decay\+\_\+fit (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{x,  }\item[{np.\+ndarray}]{y,  }\item[{str}]{mode = {\ttfamily \textquotesingle{}log-\/linregress\textquotesingle{}},  }\item[{int}]{maxfev = {\ttfamily 2000},  }\item[{}]{bounds = {\ttfamily \mbox{[}-\/1e-\/6,1e+6\mbox{]}} }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em x} & (numpy.\+ndarray)\+: x coordinate of input data points. \\
\hline
{\em y} & (numpy.\+ndarray)\+: y coordinate of input data points. \\
\hline
{\em mode} & (str, optional)\+: If mode is \textquotesingle{}log-\/linregress\textquotesingle{}, underlying algorithm will perform linear regression in $ \log(x)-\log(y) $ scale, else brutal force \\
\hline
{\em maxfev} & (int)\+: ~\newline
 \\
\hline
{\em bounds} & (list\mbox{[}float,float\mbox{]})\+:\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
popt (numpy.\+ndarray)\+: 

perr (numpy.\+ndarray)\+: 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceanko_1_1stats__util_a6f905598561c0f8c6e31dfb0b0e2d5e5}\label{namespaceanko_1_1stats__util_a6f905598561c0f8c6e31dfb0b0e2d5e5}} 
\index{anko.stats\_util@{anko.stats\_util}!fitting\_residual@{fitting\_residual}}
\index{fitting\_residual@{fitting\_residual}!anko.stats\_util@{anko.stats\_util}}
\doxysubsubsection{\texorpdfstring{fitting\_residual()}{fitting\_residual()}}
{\footnotesize\ttfamily  np.\+ndarray anko.\+stats\+\_\+util.\+fitting\+\_\+residual (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{x,  }\item[{np.\+ndarray}]{y,  }\item[{}]{func,  }\item[{}]{args,  }\item[{float}]{mask\+\_\+min = {\ttfamily None},  }\item[{bool}]{absolute\+\_\+value = {\ttfamily True},  }\item[{bool}]{standardized = {\ttfamily False} }\end{DoxyParamCaption})}



Compute the fitting residual. 


\begin{DoxyParams}{Parameters}
{\em x} & (numpy.\+ndarray)\+: x coordinate of input data points. \\
\hline
{\em y} & (numpy.\+ndarray)\+: y coordinate of input data points. \\
\hline
{\em func} & (callable)\+: Fitting function. \\
\hline
{\em args} & (numpy.\+ndarray)\+: Best estimated arguments of fitting function. \\
\hline
{\em mask\+\_\+min} & (float, optional)\+: If not None, mask resuduals that are smaller than mask\+\_\+min to zero. This is always performed before standardization. \\
\hline
{\em absolute\+\_\+value} & (bool, optional)\+: If True, return absolute value of residual. \\
\hline
{\em standardized} & (bool, optional)\+: Standardize residual to z-\/score formalism.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
res (numpy.\+ndarray)\+: Residual of each corresponding data points (x, y). 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceanko_1_1stats__util_a592ce686a07fad2982a1e051b8e751da}\label{namespaceanko_1_1stats__util_a592ce686a07fad2982a1e051b8e751da}} 
\index{anko.stats\_util@{anko.stats\_util}!flat\_histogram@{flat\_histogram}}
\index{flat\_histogram@{flat\_histogram}!anko.stats\_util@{anko.stats\_util}}
\doxysubsubsection{\texorpdfstring{flat\_histogram()}{flat\_histogram()}}
{\footnotesize\ttfamily def anko.\+stats\+\_\+util.\+flat\+\_\+histogram (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{x }\end{DoxyParamCaption})}



Deprecating... 

~\newline
Manually assign parameters of Gaussian distrinution if the given histogram is too flat. ~\newline
In this senario the histogram of data is regarded as a local segment of a larger normal-\/distribution-\/like histogram, ~\newline
with standard deviation which exceeds the current consideration of domain.

Parameters of Gaussian distribution are assigned as following\+:
\begin{DoxyEnumerate}
\item Number of appearance of mode as normalization constant, a.
\item Mode of data x as mean, x0.
\item Standard deviation is set to infinity (numpy.\+inf).
\end{DoxyEnumerate}


\begin{DoxyParams}{Parameters}
{\em x} & (numpy.\+ndarray)\+: Input values.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
popt (numpy.\+ndarray)\+: Assigned values for Gaussian distribution. 

perr (numpy.\+ndarray)\+: Errors are set to zero. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceanko_1_1stats__util_aa482297a54c4bcc67af00b259c3b03ce}\label{namespaceanko_1_1stats__util_aa482297a54c4bcc67af00b259c3b03ce}} 
\index{anko.stats\_util@{anko.stats\_util}!gaussian\_fit@{gaussian\_fit}}
\index{gaussian\_fit@{gaussian\_fit}!anko.stats\_util@{anko.stats\_util}}
\doxysubsubsection{\texorpdfstring{gaussian\_fit()}{gaussian\_fit()}}
{\footnotesize\ttfamily def anko.\+stats\+\_\+util.\+gaussian\+\_\+fit (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{x,  }\item[{bool}]{sort\+\_\+histo = {\ttfamily False},  }\item[{str}]{half = {\ttfamily None},  }\item[{int}]{maxfev = {\ttfamily 2000},  }\item[{}]{bounds = {\ttfamily \mbox{[}0,1e+6\mbox{]}} }\end{DoxyParamCaption})}



Fitting the Gaussian (normal) distribution for input data x. 


\begin{DoxyParams}{Parameters}
{\em x} & (numpy.\+ndarray)\+: Input values. ~\newline
 \\
\hline
{\em sort\+\_\+histo} & (bool, optional)\+: If True use the sorted histogram. \\
\hline
{\em half} & (str, optional)\+: ~\newline
 \\
\hline
{\em maxfev} & (int, optional)\+: Maximum step of fitting iteration. \\
\hline
{\em bounds} & (list\mbox{[}float, float\mbox{]}, optional)\+:\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
popt (numpy.\+ndarray)\+: Estimate value of a, x0 and sigma of Gaussian distribution. 

perr (numpy.\+ndarray)\+: Error of popt. Defined by the square of diagonal element of covariance matrix. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceanko_1_1stats__util_a9e0f971311c5d1013a90795d2427091c}\label{namespaceanko_1_1stats__util_a9e0f971311c5d1013a90795d2427091c}} 
\index{anko.stats\_util@{anko.stats\_util}!general\_erf@{general\_erf}}
\index{general\_erf@{general\_erf}!anko.stats\_util@{anko.stats\_util}}
\doxysubsubsection{\texorpdfstring{general\_erf()}{general\_erf()}}
{\footnotesize\ttfamily  np.\+ndarray anko.\+stats\+\_\+util.\+general\+\_\+erf (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{x,  }\item[{float}]{a,  }\item[{float}]{b,  }\item[{float}]{x0 }\end{DoxyParamCaption})}



Calculate the generalize error function of input array x. 

\begin{equation*} f(x) = \begin{cases} a, & x < x_0, \\ \frac{a+b}{2}, & x = x_0, \\ b, & x > x_0. \end{cases} \end{equation*}


\begin{DoxyParams}{Parameters}
{\em x} & (numpy.\+ndarray)\+: Input values. \\
\hline
{\em a} & (float)\+: Value of first stair. \\
\hline
{\em b} & (float)\+: Value of second stair. \\
\hline
{\em x0} & (float)\+: Location of the cliff.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
out (numpy.\+ndarray)\+: Output array. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceanko_1_1stats__util_a4f434d24322b90d1d03cf689847ea76a}\label{namespaceanko_1_1stats__util_a4f434d24322b90d1d03cf689847ea76a}} 
\index{anko.stats\_util@{anko.stats\_util}!general\_erf\_fit@{general\_erf\_fit}}
\index{general\_erf\_fit@{general\_erf\_fit}!anko.stats\_util@{anko.stats\_util}}
\doxysubsubsection{\texorpdfstring{general\_erf\_fit()}{general\_erf\_fit()}}
{\footnotesize\ttfamily def anko.\+stats\+\_\+util.\+general\+\_\+erf\+\_\+fit (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{x,  }\item[{np.\+ndarray}]{y,  }\item[{bool}]{three\+\_\+stair = {\ttfamily False},  }\item[{int}]{maxfev = {\ttfamily 2000},  }\item[{}]{bounds = {\ttfamily \mbox{[}0,1e+6\mbox{]}} }\end{DoxyParamCaption})}



Fitting generalize error function for input data (x, y). 


\begin{DoxyParams}{Parameters}
{\em x} & (numpy.\+ndarray)\+: x coordinate of input data points. \\
\hline
{\em y} & (numpy.\+ndarray)\+: y coordinate of input data points. \\
\hline
{\em three\+\_\+stair} & (bool)\+: If True, employing three stair error function for fitting. \\
\hline
{\em maxfev} & (int)\+: Maximum step of fitting iteration. \\
\hline
{\em bounds} & (list\mbox{[}float\mbox{]})\+:\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
popt (numpy.\+ndarray)\+: 

perr (numpy.\+ndarray)\+: 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceanko_1_1stats__util_ae5da820a4ff2ba172cc895f7aed1a7c6}\label{namespaceanko_1_1stats__util_ae5da820a4ff2ba172cc895f7aed1a7c6}} 
\index{anko.stats\_util@{anko.stats\_util}!get\_histogram@{get\_histogram}}
\index{get\_histogram@{get\_histogram}!anko.stats\_util@{anko.stats\_util}}
\doxysubsubsection{\texorpdfstring{get\_histogram()}{get\_histogram()}}
{\footnotesize\ttfamily def anko.\+stats\+\_\+util.\+get\+\_\+histogram (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{x,  }\item[{bool}]{sort\+\_\+histo = {\ttfamily False} }\end{DoxyParamCaption})}



Return the corresponding histogram of the data x. 


\begin{DoxyParams}{Parameters}
{\em x} & (numpy.\+ndarray)\+: One-\/dimensional array of data. \\
\hline
{\em sort\+\_\+histo} & (bool, optional)\+: If True return the sorted histogram.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
keys\+: Set of data x (no duplicate). 

vals\+: Number of appearance for each key in keys. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceanko_1_1stats__util_a0f75e0a66974df60bf657d244f516619}\label{namespaceanko_1_1stats__util_a0f75e0a66974df60bf657d244f516619}} 
\index{anko.stats\_util@{anko.stats\_util}!is\_oscillating@{is\_oscillating}}
\index{is\_oscillating@{is\_oscillating}!anko.stats\_util@{anko.stats\_util}}
\doxysubsubsection{\texorpdfstring{is\_oscillating()}{is\_oscillating()}}
{\footnotesize\ttfamily  bool anko.\+stats\+\_\+util.\+is\+\_\+oscillating (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{x,  }\item[{float}]{osci\+\_\+freq\+\_\+th = {\ttfamily 0.3} }\end{DoxyParamCaption})}



Determine whether the input array x is oscillating over its mean with frequency larger than osci\+\_\+freq\+\_\+th. 

This is equivalent to find the number of solutions of the following equation

\begin{equation*} x - \mu = 0. \end{equation*}


\begin{DoxyParams}{Parameters}
{\em x} & (numpy.\+ndarray)\+: \\
\hline
{\em osci\+\_\+freq\+\_\+th} & (float)\+:\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
out (bool)\+: 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceanko_1_1stats__util_afe9294ceb5073c65f77b6c7894349ef7}\label{namespaceanko_1_1stats__util_afe9294ceb5073c65f77b6c7894349ef7}} 
\index{anko.stats\_util@{anko.stats\_util}!left\_half\_normal\_distr@{left\_half\_normal\_distr}}
\index{left\_half\_normal\_distr@{left\_half\_normal\_distr}!anko.stats\_util@{anko.stats\_util}}
\doxysubsubsection{\texorpdfstring{left\_half\_normal\_distr()}{left\_half\_normal\_distr()}}
{\footnotesize\ttfamily  np.\+ndarray anko.\+stats\+\_\+util.\+left\+\_\+half\+\_\+normal\+\_\+distr (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{x,  }\item[{float}]{a,  }\item[{float}]{x0,  }\item[{float}]{sigma }\end{DoxyParamCaption})}



Calculate left-\/side half normal distribution of input array x. 


\begin{DoxyParams}{Parameters}
{\em x} & (numpy.\+ndarray)\+: Input values. \\
\hline
{\em a} & (float)\+: Overall normalization constant. \\
\hline
{\em x0} & (float)\+: Mean. \\
\hline
{\em sigma} & (float)\+: Standard deviation.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
out (numpy.\+ndarray)\+: Output array. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceanko_1_1stats__util_a15eb3a4bb50aa7e2825e03c741684c0e}\label{namespaceanko_1_1stats__util_a15eb3a4bb50aa7e2825e03c741684c0e}} 
\index{anko.stats\_util@{anko.stats\_util}!linear\_regression@{linear\_regression}}
\index{linear\_regression@{linear\_regression}!anko.stats\_util@{anko.stats\_util}}
\doxysubsubsection{\texorpdfstring{linear\_regression()}{linear\_regression()}}
{\footnotesize\ttfamily def anko.\+stats\+\_\+util.\+linear\+\_\+regression (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{x,  }\item[{np.\+ndarray}]{y }\end{DoxyParamCaption})}



Fitting linear ansatz for input data (x, y). 

\begin{equation*} f(x) = intercept + slope \times x. \end{equation*}


\begin{DoxyParams}{Parameters}
{\em x} & (numpy.\+ndarray)\+: x coordinate of input data points. \\
\hline
{\em y} & (numpy.\+ndarray)\+: y coordinate of input data points.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
r\+\_\+sq (float)\+: Coefficient of determination. 

intercept (float)\+: Intercept of the regression line. 

slope (float)\+: Slope of the regression line. 

p\+\_\+value (float)\+: Two-\/sided p-\/value for a hypothesis test whose null hypothesis is that the slope is zero, ~\newline
 using Wald Test with t-\/distribution of the test statistic. 

std\+\_\+err (float)\+: Standard error of the estimated gradient. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceanko_1_1stats__util_a043c3334f258dda9e528ab8a51ea053b}\label{namespaceanko_1_1stats__util_a043c3334f258dda9e528ab8a51ea053b}} 
\index{anko.stats\_util@{anko.stats\_util}!normal\_distr@{normal\_distr}}
\index{normal\_distr@{normal\_distr}!anko.stats\_util@{anko.stats\_util}}
\doxysubsubsection{\texorpdfstring{normal\_distr()}{normal\_distr()}}
{\footnotesize\ttfamily  np.\+ndarray anko.\+stats\+\_\+util.\+normal\+\_\+distr (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{x,  }\item[{float}]{a,  }\item[{float}]{x0,  }\item[{float}]{sigma }\end{DoxyParamCaption})}



Calculate normal distribution of input array x. 

\begin{equation*} f(x) = a \exp\left(-\frac{\left(x-x_0\right)^2}{2\sigma^2}\right). \end{equation*}


\begin{DoxyParams}{Parameters}
{\em x} & (numpy.\+ndarray)\+: Input values. \\
\hline
{\em a} & (float)\+: Overall normalization constant. \\
\hline
{\em x0} & (float)\+: Mean. \\
\hline
{\em sigma} & (float)\+: Standard deviation.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
out (numpy.\+ndarray)\+: Output array. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceanko_1_1stats__util_ad0683a7fc4d68fa7937dbe214d554997}\label{namespaceanko_1_1stats__util_ad0683a7fc4d68fa7937dbe214d554997}} 
\index{anko.stats\_util@{anko.stats\_util}!right\_half\_normal\_distr@{right\_half\_normal\_distr}}
\index{right\_half\_normal\_distr@{right\_half\_normal\_distr}!anko.stats\_util@{anko.stats\_util}}
\doxysubsubsection{\texorpdfstring{right\_half\_normal\_distr()}{right\_half\_normal\_distr()}}
{\footnotesize\ttfamily  np.\+ndarray anko.\+stats\+\_\+util.\+right\+\_\+half\+\_\+normal\+\_\+distr (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{x,  }\item[{float}]{a,  }\item[{float}]{x0,  }\item[{float}]{sigma }\end{DoxyParamCaption})}



Calculate right-\/side half normal distribution of input array x. 


\begin{DoxyParams}{Parameters}
{\em x} & (numpy.\+ndarray)\+: Input values. \\
\hline
{\em a} & (float)\+: Overall normalization constant. \\
\hline
{\em x0} & (float)\+: Mean. \\
\hline
{\em sigma} & (float)\+: Standard deviation.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
out (numpy.\+ndarray)\+: Output array. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceanko_1_1stats__util_a1467292292fb037a7b879c3a66700499}\label{namespaceanko_1_1stats__util_a1467292292fb037a7b879c3a66700499}} 
\index{anko.stats\_util@{anko.stats\_util}!smoothness@{smoothness}}
\index{smoothness@{smoothness}!anko.stats\_util@{anko.stats\_util}}
\doxysubsubsection{\texorpdfstring{smoothness()}{smoothness()}}
{\footnotesize\ttfamily def anko.\+stats\+\_\+util.\+smoothness (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{x,  }\item[{bool}]{normalize = {\ttfamily False} }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em x} & (numpy.\+ndarray)\+: \\
\hline
{\em normalize} & (bool)\+:\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sm (numpy.\+ndarray)\+: 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceanko_1_1stats__util_a2efdfc173ad6b38025bfd48da53f160a}\label{namespaceanko_1_1stats__util_a2efdfc173ad6b38025bfd48da53f160a}} 
\index{anko.stats\_util@{anko.stats\_util}!three\_stair\_erf@{three\_stair\_erf}}
\index{three\_stair\_erf@{three\_stair\_erf}!anko.stats\_util@{anko.stats\_util}}
\doxysubsubsection{\texorpdfstring{three\_stair\_erf()}{three\_stair\_erf()}}
{\footnotesize\ttfamily  np.\+ndarray anko.\+stats\+\_\+util.\+three\+\_\+stair\+\_\+erf (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{x,  }\item[{float}]{c0,  }\item[{float}]{c1,  }\item[{float}]{c2,  }\item[{float}]{x1,  }\item[{float}]{x2 }\end{DoxyParamCaption})}



Calculate the generalize error function with three stairs for input array x. 

\begin{equation*} f(x) = \begin{cases} c_0, & x < x_1, \\ \frac{c_0+c_1}{2}, & x = x_1, \\ c_1, & x_1< x < x_2, \\ \frac{c_1+c_2}{2}, & x = x_2, \\ c_2, & x > x_2. \end{cases} \end{equation*}


\begin{DoxyParams}{Parameters}
{\em x} & (numpy.\+ndarray)\+: Input values. \\
\hline
{\em c0} & (float)\+: Value of first stair. \\
\hline
{\em c1} & (float)\+: Value of second stair. \\
\hline
{\em c2} & (float)\+: Value of third stair. \\
\hline
{\em x1} & (float)\+: Location of the first cliff. \\
\hline
{\em x2} & (float)\+: Location of the second cliff.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
out (numpy.\+ndarray)\+: Output array. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceanko_1_1stats__util_a9b2e2041bcd620bb46b85e933fe45697}\label{namespaceanko_1_1stats__util_a9b2e2041bcd620bb46b85e933fe45697}} 
\index{anko.stats\_util@{anko.stats\_util}!z\_normalization@{z\_normalization}}
\index{z\_normalization@{z\_normalization}!anko.stats\_util@{anko.stats\_util}}
\doxysubsubsection{\texorpdfstring{z\_normalization()}{z\_normalization()}}
{\footnotesize\ttfamily  np.\+ndarray anko.\+stats\+\_\+util.\+z\+\_\+normalization (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{x }\end{DoxyParamCaption})}



Perform z-\/score normalizaion on input array x. 

\begin{equation*} z = \frac{x-\mu}{\sigma}. \end{equation*}


\begin{DoxyParams}{Parameters}
{\em x} & (numpy.\+ndarray)\+: Input values.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
normalized\+\_\+x (numpy.\+ndarray)\+: Output array. 
\end{DoxyReturn}
